import streamlit as st
import pandas as pd
import joblib
import numpy as np
import os

# --- 1. Page Configuration ---
st.set_page_config(
    page_title="Athletic Diet Recommendation System",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- 2. Custom CSS for Professional Design ---
st.markdown("""
<style>
/* Base Resets and Font */
@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap');
* {box-sizing: border-box; font-family: 'IBM Plex Sans', sans-serif;}
header, footer {visibility: hidden;}

/* Main App Background */
.stApp {
    background: #ffffff;
    color: #202124;
}

/* Sidebar Styling */
[data-testid="stSidebar"] {
    background-color: #ffffff;
    border-right: 1px solid rgba(60,64,67,0.08);
    padding: 1.5rem 1rem;
    box-shadow: none;
}

/* Headers */
h1 {
    color: #202124;
    font-weight: 700;
    font-size: 2.0rem !important;
    margin: 0.5rem 0 1rem 0;
    text-align: center;
    letter-spacing: -0.2px;
    line-height: 1.15;
}

h2, h3 {
    color: #202124;
    font-weight: 600;
    letter-spacing: -0.2px;
    margin: 1rem 0;
}

/* Cards */
.main-card {
    background: #ffffff;
    border: 1px solid rgba(60,64,67,0.08);
    border-radius: 8px;
    padding: 1.4rem;
    margin: 1rem 0;
    transition: transform 0.12s ease, box-shadow 0.12s ease;
}

.main-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 14px rgba(60,64,67,0.06);
}

/* Buttons */
.stButton > button {
    width: 100%;
    height: 3rem;
    background: linear-gradient(90deg, #1a73e8, #1a73e8) !important;
    color: #ffffff !important;
    border: none !important;
    border-radius: 6px !important;
    font-weight: 600 !important;
    letter-spacing: 0.4px;
    text-transform: uppercase;
    font-size: 0.9rem !important;
    transition: transform 0.12s ease, box-shadow 0.12s ease !important;
}

.stButton > button:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 14px rgba(26,115,232,0.18) !important;
}

/* Metrics */
[data-testid="stMetricValue"] {
    color: #202124 !important;
    font-size: 1.4rem !important;
    font-weight: 700 !important;
}

[data-testid="metric-label"], .stMetricLabel {
    color: #202124 !important;
    font-size: 0.95rem !important;
    font-weight: 600 !important;
    opacity: 0.95 !important;
}

/* Remove default DataFrame styling since we are using cards */
[data-testid="stDataFrame"] {
    display: none;
}
</style>
""", unsafe_allow_html=True)


# --- 3. Load Models and Data ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

def load_data():
    # Loading the database generated by train.py
    file_path = os.path.join(BASE_DIR, 'improved_food_database.csv')
    try:
        return pd.read_csv(file_path)
    except FileNotFoundError:
        st.error(f"‚ùå 'improved_food_database.csv' not found at {file_path}. Please run train.py first.")
        return None

@st.cache_resource
def load_model():
    file_path = os.path.join(BASE_DIR, 'meal_plan_model.joblib')
    try:
        return joblib.load(file_path)
    except FileNotFoundError:
        st.error(f"‚ùå 'meal_plan_model.joblib' not found. Please run train.py first.")
        return None

@st.cache_resource
def load_clustering_models():
    """Load K-Means model, scaler, and cluster mapping from train.py"""
    try:
        kmeans_path = os.path.join(BASE_DIR, 'food_kmeans_model.joblib')
        scaler_path = os.path.join(BASE_DIR, 'food_scaler.joblib')
        mapping_path = os.path.join(BASE_DIR, 'cluster_mealplan_mapping.joblib')
        
        kmeans = joblib.load(kmeans_path)
        scaler = joblib.load(scaler_path)
        mapping = joblib.load(mapping_path)
        return kmeans, scaler, mapping
    except FileNotFoundError:
        st.warning("‚ö†Ô∏è K-Means models not found. Ensure train.py ran successfully.")
        return None, None, None

@st.cache_resource
def load_performance_metrics():
    """Load saved model performance metrics"""
    try:
        rf_path = os.path.join(BASE_DIR, 'model_performance_metrics.joblib')
        cluster_path = os.path.join(BASE_DIR, 'clustering_metrics.joblib')
        
        rf_metrics = joblib.load(rf_path)
        cluster_metrics = joblib.load(cluster_path)
        return rf_metrics, cluster_metrics
    except FileNotFoundError:
        return None, None

# Load everything
food_db = load_data()
model = load_model()
kmeans_model, kmeans_scaler, cluster_mapping = load_clustering_models()
rf_metrics, cluster_metrics = load_performance_metrics()

if food_db is None or model is None:
    st.stop()

# Ensure Mapping Exists
if 'Meal_Plan' not in food_db.columns and cluster_mapping is not None:
    food_db['Meal_Plan'] = food_db['Food_Cluster'].map(cluster_mapping).fillna('Balanced')


# --- 4. Helper Functions ---
def calculate_bmr(age, weight_kg, height_cm, gender):
    """Harris-Benedict Equation"""
    if gender == "Male":
        return 88.362 + (13.397 * weight_kg) + (4.799 * height_cm) - (5.677 * age)
    else:
        return 447.593 + (9.247 * weight_kg) + (3.098 * height_cm) - (4.330 * age)

def calculate_tdee(bmr, activity_level):
    """Total Daily Energy Expenditure"""
    activity_multipliers = {
        "Light Training (1‚Äì3 days/week)": 1.375,
        "Moderate Training (3‚Äì5 days/week)": 1.55,
        "High Training (6‚Äì7 days/week)": 1.725
    }
    return bmr * activity_multipliers.get(activity_level, 1.55)

def map_goal_to_model_format(goal):
    """Map user UI goal to the specific keys used in train.py dictionary"""
    # These keys MUST match the 'ideal_profiles' keys in train.py
    mapping = {
        "Build Muscle": "Build Muscle",
        "Endurance": "Endurance",
        "HIIT": "HIIT",
        "Weight Loss": "Weight Loss",
        "General / Balanced": "Balanced"
    }
    return mapping.get(goal, "Balanced")

# --- RECOMMENDATION ENGINE ---
def get_recommendations_by_cluster(food_db, predicted_plan):
    """
    Select meals based on the K-Means cluster label.
    Synced with train.py's 'Tuned Ideal Profiles'.
    """
    if food_db is None or food_db.empty:
        return []

    bmr = st.session_state.get('bmr', 2000)
    
    # Meal Splits
    meal_calories = {
        "Breakfast": bmr * 0.30,
        "Lunch": bmr * 0.40,
        "Dinner": bmr * 0.30
    }

    # --- UPDATED NUTRITION LOGIC (Matches train.py Tuned Ratios) ---
    # These guidelines help filter the 'Best' foods within the assigned cluster
    nutrition_requirements = {
        "Weight Loss": { 
            # train.py: High Protein (0.60), Low Carb (0.10)
            'Proteins': {'min': 25, 'target': 40},
            'Carbs': {'min': 0, 'target': 15}, 
            'Fats': {'min': 5, 'target': 20}
        },
        "Build Muscle": { 
            # train.py: High Protein (0.40), Mod Carb (0.25)
            'Proteins': {'min': 20, 'target': 35},
            'Carbs': {'min': 20, 'target': 30},
            'Fats': {'min': 15, 'target': 25}
        },
        "Endurance": { 
            # train.py: High Carb (0.65), Low Pro (0.15)
            'Proteins': {'min': 5, 'target': 15},
            'Carbs': {'min': 40, 'target': 60},
            'Fats': {'min': 5, 'target': 15}
        },
        "HIIT": { 
            # train.py: Mod Carb (0.45), Mod Pro (0.30)
            'Proteins': {'min': 15, 'target': 25},
            'Carbs': {'min': 30, 'target': 45},
            'Fats': {'min': 10, 'target': 20}
        },
        "Balanced": { 
            # train.py: High Fat/Balanced (F=0.60)
            'Proteins': {'min': 10, 'target': 20},
            'Carbs': {'min': 20, 'target': 40},
            'Fats': {'min': 20, 'target': 35}
        }
    }
    
    plan_reqs = nutrition_requirements.get(predicted_plan, nutrition_requirements["Balanced"])
    
    # 1. Filter by Cluster Label (The most important step)
    # We only look at foods that K-Means put into the "Weight Loss" bucket, etc.
    filtered = food_db[food_db['Meal_Plan'] == predicted_plan]
    
    if filtered.empty:
        st.warning(f"‚ö†Ô∏è No foods found in cluster '{predicted_plan}'. Using all foods.")
        filtered = food_db

    meals = []
    meal_types = ["Breakfast", "Lunch", "Dinner"]
    
    for meal_type in meal_types:
        target_calories = meal_calories[meal_type]
        
        # 2. Refine within the cluster
        # Try to find foods that strictly meet the min requirements
        refined_foods = filtered[
            (filtered['Proteins'] >= plan_reqs['Proteins']['min']) &
            (filtered['Carbs'] >= plan_reqs['Carbs']['min'])
        ]
        
        # Fallback if refined filter is too strict
        if refined_foods.empty:
            refined_foods = filtered 
            
        # 3. Calorie Matching
        calorie_margin = 0.25
        calorie_filtered = refined_foods[
            (refined_foods['Calories'] >= target_calories * (1 - calorie_margin)) &
            (refined_foods['Calories'] <= target_calories * (1 + calorie_margin))
        ]
        
        if calorie_filtered.empty:
            # Find closest calorie match
            calorie_filtered = refined_foods.iloc[
                (refined_foods['Calories'] - target_calories).abs().argsort()[:5]
            ]
        
        if calorie_filtered.empty:
            continue

        # Pick one
        selected_food = calorie_filtered.sample(1).iloc[0]
        
        # Score calculation for display
        macro_scores = {
            'Proteins': min(selected_food['Proteins'] / plan_reqs['Proteins']['target'], 1.0),
            'Carbs': min(selected_food['Carbs'] / plan_reqs['Carbs']['target'], 1.0),
            'Fats': min(selected_food['Fats'] / plan_reqs['Fats']['target'], 1.0)
        }
        
        meals.append({
            "Meal": meal_type,
            "Food": selected_food.get('meal_name', 'Unknown'),
            "Target Calories": f"{target_calories:.0f}",
            "Actual Calories": f"{selected_food.get('Calories', 0):.0f}",
            "Proteins": f"{selected_food.get('Proteins', 0):.1f}g",
            "Carbs": f"{selected_food.get('Carbs', 0):.1f}g",
            "Fats": f"{selected_food.get('Fats', 0):.1f}g",
            "Calories": f"{selected_food.get('Calories', 0):.0f} kcal",
            "Macro Score": f"{sum(macro_scores.values())/3:.0%}",
            "Cluster_Name": predicted_plan
        })

    return meals


# --- 5. Sidebar ---
with st.sidebar:
    st.title("üí™ POWER")
    st.markdown("### AI-Powered Nutrition")
    
    with st.expander("üéØ System Features"):
        st.markdown("""
        - **K-Means**: Groups foods by nutrient ratios.
        - **Random Forest**: Aligns user profile to clusters.
        - **Tuned Mapping**: Custom logic for athletic goals.
        """)
    
    # Performance Metrics (Section 3.7)
    if rf_metrics is not None:
        with st.expander("üìà Model Performance"):
            st.metric("RF Accuracy", f"{rf_metrics['accuracy']*100:.2f}%")
            st.metric("Precision", f"{rf_metrics['precision']:.4f}")
            st.metric("Recall", f"{rf_metrics['recall']:.4f}")
            st.metric("F1-Score", f"{rf_metrics['f1_score']:.4f}")
    
    if cluster_metrics is not None:
        with st.expander("üìä Clustering Stats"):
            st.metric("Silhouette Score", f"{cluster_metrics['silhouette_score']:.4f}")
            st.metric("Optimal K", cluster_metrics['optimal_k'])


# --- 6. Main Page ---
st.title("Athletic Diet AI")
st.markdown("<div style='text-align: center; color: #666;'>Precision Nutrition for Peak Performance</div>", unsafe_allow_html=True)

# --- Input Form ---
st.markdown('<div class="main-card">', unsafe_allow_html=True)
st.subheader("Athlete Profile")

col1, col2 = st.columns(2)
with col1:
    age = st.number_input("Age", 15, 80, 25)
    gender = st.selectbox("Gender", ("Male", "Female"))
    height_cm = st.number_input("Height (cm)", 140, 220, 170)
    weight_kg = st.number_input("Weight (kg)", 40, 150, 70)
with col2:
    # Goals match train.py keys
    goals = ["Build Muscle", "Endurance", "HIIT", "Weight Loss", "General / Balanced"]
    goal = st.selectbox("Performance Goal", goals)
    activity = st.selectbox("Training Frequency", (
        "Light Training (1‚Äì3 days/week)",
        "Moderate Training (3‚Äì5 days/week)",
        "High Training (6‚Äì7 days/week)"
    ), index=1)

    st.markdown("<br>", unsafe_allow_html=True)
    btn = st.button("GENERATE PLAN", use_container_width=True)
st.markdown('</div>', unsafe_allow_html=True)


# --- 7. Logic Execution ---

if btn:
    with st.spinner("Analyzing metabolic needs..."):
        # --- 1. CALCULATIONS ---
        height_m = height_cm / 100
        bmi = weight_kg / (height_m ** 2)
        bmr = calculate_bmr(age, weight_kg, height_cm, gender)
        tdee = calculate_tdee(bmr, activity)

        exp_level = {
            "Light Training (1‚Äì3 days/week)": 2,
            "Moderate Training (3‚Äì5 days/week)": 4,
            "High Training (6‚Äì7 days/week)": 6
        }[activity]

        # --- 2. DEFINE USER DATA ---
        user_data = {
            'Age': age, 
            'Weight (kg)': weight_kg, 
            'Height (m)': height_m, 
            'BMI': bmi,
            'Fat_Percentage': 18.0,  # Standard Athlete Avg (Report Limitation)
            'Avg_BPM': 130,          # Standard Avg (Report Limitation)
            'Resting_BPM': 65,       # Standard Avg (Report Limitation)
            'Experience_Level': exp_level, 
            'Gender': gender,
            'Goals': map_goal_to_model_format(goal)
        }

        # --- 3. PREDICTION & HYBRID LOGIC ---
        # Create DataFrame for Model
        user_df = pd.DataFrame([user_data])
        
        # Run AI Prediction
        try:
            raw_prediction = model.predict(user_df)[0]
        except Exception as e:
            raw_prediction = "Balanced"
            st.error(f"Model Error: {e}")

        # UPDATED TRANSLATION LAYER
        prediction_mapper = {
            "High Protein High Carb": "HIIT",         
            "High Protein Low Carb":  "Weight Loss",  
            "Low Carb High Fat":      "Balanced",     
            "High Carb Low Fat":      "Endurance",    
            "Balanced":               "Balanced",
            "Build Muscle":           "Build Muscle", 
            "Ketogenic":              "Weight Loss",
            "High Protein":           "Build Muscle", 
            "High Protein High Carb High Fat": "HIIT",
            # Catch-alls for safety
            "Weight Loss": "Weight Loss",
            "Endurance": "Endurance",
            "Muscle Gain": "Build Muscle" 
        }
        
        # Get the AI's suggestion (defaults to Balanced if not found)
        ai_suggested_plan = prediction_mapper.get(raw_prediction, "Balanced")

        # --- DECISION LOGIC ---
        # 1. If user picked a specific goal, RESPECT IT.
        # 2. If user picked "General / Balanced", trust the AI.
        
        if user_data['Goals'] != "Balanced":
            final_plan = user_data['Goals']  # User is King
            
            # Optional: Show a notification if AI disagrees
            if final_plan != ai_suggested_plan:
                st.toast(f"‚ÑπÔ∏è Note: You selected '{final_plan}', but based on stats the AI suggested '{ai_suggested_plan}'.")
        else:
            final_plan = ai_suggested_plan   # User is unsure, use AI
            st.success(f"ü§ñ AI Analysis: Based on your biometrics, we recommend the **{final_plan}** strategy.")

        # --- 4. GENERATE MEALS ---
        meals = get_recommendations_by_cluster(food_db, final_plan)
        
        # --- 5. SAVE STATE ---
        st.session_state.update({
            'bmr': bmr,
            'tdee': tdee,
            'bmi': bmi,
            'predicted_plan': final_plan,
            'user_data': user_data,
            'meal_plan': pd.DataFrame(meals)
        })


# --- RECOMMENDATION ENGINE (Updated for Variety) ---
def get_recommendations_by_cluster(food_db, predicted_plan, exclude_names=None):
    """
    Select meals based on cluster, ensuring no repeats.
    """
    if food_db is None or food_db.empty:
        return []

    # 1. Initialize Exclusion List (Avoids foods passed from previous run)
    if exclude_names is None:
        exclude_names = []
    
    # We use a set for faster tracking of what we've picked so far
    used_foods = set(exclude_names)

    bmr = st.session_state.get('bmr', 2000)
    
    meal_calories = {
        "Breakfast": bmr * 0.30,
        "Lunch": bmr * 0.40,
        "Dinner": bmr * 0.30
    }

    # Nutrition Logic (Same as before)
    nutrition_requirements = {
        "Weight Loss": {'Proteins': {'min': 25, 'target': 40}, 'Carbs': {'min': 0, 'target': 15}, 'Fats': {'min': 5, 'target': 20}},
        "Build Muscle": {'Proteins': {'min': 20, 'target': 35}, 'Carbs': {'min': 20, 'target': 30}, 'Fats': {'min': 15, 'target': 25}},
        "Endurance": {'Proteins': {'min': 5, 'target': 15}, 'Carbs': {'min': 40, 'target': 60}, 'Fats': {'min': 5, 'target': 15}},
        "HIIT": {'Proteins': {'min': 15, 'target': 25}, 'Carbs': {'min': 30, 'target': 45}, 'Fats': {'min': 10, 'target': 20}},
        "Balanced": {'Proteins': {'min': 10, 'target': 20}, 'Carbs': {'min': 20, 'target': 40}, 'Fats': {'min': 20, 'target': 35}}
    }
    
    plan_reqs = nutrition_requirements.get(predicted_plan, nutrition_requirements["Balanced"])
    
    # Filter by Cluster
    cluster_filtered = food_db[food_db['Meal_Plan'] == predicted_plan]
    
    if cluster_filtered.empty:
        cluster_filtered = food_db # Fallback

    meals = []
    meal_types = ["Breakfast", "Lunch", "Dinner"]
    
    for meal_type in meal_types:
        target_calories = meal_calories[meal_type]
        
        # --- VARIETY CHECK: Remove foods we have already used ---
        # This ensures Breakfast != Lunch != Dinner, AND distinct from previous generation
        available_foods = cluster_filtered[~cluster_filtered['meal_name'].isin(used_foods)]
        
        # Fallback: If we ran out of unique foods, reset and look at the whole cluster again
        if available_foods.empty:
            available_foods = cluster_filtered

        # Refine by Macros
        refined_foods = available_foods[
            (available_foods['Proteins'] >= plan_reqs['Proteins']['min']) &
            (available_foods['Carbs'] >= plan_reqs['Carbs']['min'])
        ]
        
        if refined_foods.empty:
            refined_foods = available_foods 
            
        # Calorie Matching
        calorie_margin = 0.25
        calorie_filtered = refined_foods[
            (refined_foods['Calories'] >= target_calories * (1 - calorie_margin)) &
            (refined_foods['Calories'] <= target_calories * (1 + calorie_margin))
        ]
        
        if calorie_filtered.empty:
            calorie_filtered = refined_foods.iloc[
                (refined_foods['Calories'] - target_calories).abs().argsort()[:10]
            ]
        
        if calorie_filtered.empty:
            continue

        # Pick one random food
        selected_food = calorie_filtered.sample(1).iloc[0]
        
        # CRITICAL: Add this food to 'used_foods' so it won't be picked for the next meal
        used_foods.add(selected_food['meal_name'])
        
        # Calculate Score
        macro_scores = {
            'Proteins': min(selected_food['Proteins'] / plan_reqs['Proteins']['target'], 1.0),
            'Carbs': min(selected_food['Carbs'] / plan_reqs['Carbs']['target'], 1.0),
            'Fats': min(selected_food['Fats'] / plan_reqs['Fats']['target'], 1.0)
        }
        
        meals.append({
            "Meal": meal_type,
            "Food": selected_food.get('meal_name', 'Unknown'),
            "Target Calories": f"{target_calories:.0f}",
            "Actual Calories": f"{selected_food.get('Calories', 0):.0f}",
            "Proteins": f"{selected_food.get('Proteins', 0):.1f}g",
            "Carbs": f"{selected_food.get('Carbs', 0):.1f}g",
            "Fats": f"{selected_food.get('Fats', 0):.1f}g",
            "Calories": f"{selected_food.get('Calories', 0):.0f} kcal",
            "Macro Score": f"{sum(macro_scores.values())/3:.0%}",
            "Cluster_Name": predicted_plan
        })

    return meals


# --- 8. Display Results ---
if st.session_state.get('predicted_plan'):
    st.markdown("<div class='main-card'>", unsafe_allow_html=True)
    
    st.subheader(f"Recommended Strategy: {st.session_state['predicted_plan']}")
    
    # User Metrics
    col1, col2, col3 = st.columns(3)
    col1.metric("BMI", f"{st.session_state['bmi']:.1f}")
    col2.metric("BMR (Base)", f"{st.session_state['bmr']:.0f} kcal")
    col3.metric("TDEE (Target)", f"{st.session_state['tdee']:.0f} kcal")

    st.markdown("---")
    
    # Meal Plan Display (Card View)
    if not st.session_state['meal_plan'].empty:
        st.subheader("Daily Meal Plan")
        
        # Show Nutritional Focus based on selection
        plan = st.session_state['predicted_plan']
        focus_text = ""
        if plan == "Endurance":
            focus_text = "‚ö° **Focus:** High Carbohydrates for sustained energy."
        elif plan == "Weight Loss":
            focus_text = "üî• **Focus:** High Protein, Low Calorie density for fat loss."
        elif plan == "Build Muscle":
            focus_text = "üí™ **Focus:** High Protein with moderate fats for recovery."
        elif plan == "HIIT":
            focus_text = "üèÉ **Focus:** Moderate Carbs & Protein for explosive energy."
        elif plan == "Balanced":
            focus_text = "‚öñÔ∏è **Focus:** Even distribution of macros for general health."
            
        st.info(focus_text)

        # Custom CSS for Meal Cards
        st.markdown("""
        <style>
        .meal-header {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1a73e8;
            margin-bottom: 0.2rem;
        }
        .food-name {
            font-size: 1.4rem;
            font-weight: 600;
            color: #202124;
            margin-bottom: 1rem;
        }
        .macro-box {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 0.8rem;
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        .macro-value {
            font-weight: 700;
            font-size: 1.1rem;
            color: #202124;
        }
        .macro-label {
            font-size: 0.8rem;
            color: #5f6368;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        </style>
        """, unsafe_allow_html=True)

        # Iterate through meals to create cards
        meal_emojis = {"Breakfast": "üç≥", "Lunch": "ü•ó", "Dinner": "üçΩÔ∏è"}
        
        for index, row in st.session_state['meal_plan'].iterrows():
            with st.container():
                st.markdown(f"""
                <div style="background-color: white; padding: 1.5rem; border-radius: 12px; 
                            border: 1px solid rgba(60,64,67,0.12); box-shadow: 0 2px 6px rgba(60,64,67,0.05); margin-bottom: 1rem;">
                    <div class="meal-header">{meal_emojis.get(row['Meal'], 'üç±')} {row['Meal']}</div>
                    <div class="food-name">{row['Food']}</div>
                </div>
                """, unsafe_allow_html=True)
                
                # Create 4 columns for macros inside the card context
                m1, m2, m3, m4 = st.columns(4)
                
                with m1:
                    st.markdown(f"""
                    <div class="macro-box">
                        <div class="macro-label">Protein</div>
                        <div class="macro-value" style="color: #d93025;">{row['Proteins']}</div>
                    </div>
                    """, unsafe_allow_html=True)
                with m2:
                    st.markdown(f"""
                    <div class="macro-box">
                        <div class="macro-label">Carbs</div>
                        <div class="macro-value" style="color: #1e8e3e;">{row['Carbs']}</div>
                    </div>
                    """, unsafe_allow_html=True)
                with m3:
                    st.markdown(f"""
                    <div class="macro-box">
                        <div class="macro-label">Fats</div>
                        <div class="macro-value" style="color: #f9ab00;">{row['Fats']}</div>
                    </div>
                    """, unsafe_allow_html=True)
                with m4:
                    st.markdown(f"""
                    <div class="macro-box" style="background-color: #e8f0fe; border-color: #d2e3fc;">
                        <div class="macro-label">Calories</div>
                        <div class="macro-value" style="color: #1967d2;">{row['Calories']}</div>
                    </div>
                    """, unsafe_allow_html=True)
                
                st.write("") # Spacer between cards

        # Totals Footer
        df = st.session_state['meal_plan']
        total_cals = sum(float(str(x).split()[0]) for x in df['Calories'])
        
        st.markdown("---")
        st.caption(f"üìä **Daily Summary:** Total Intake: **{total_cals:.0f} kcal** | Target: **{st.session_state['tdee']:.0f} kcal**")
        
    else:
        st.error("Could not generate meals. Please check database connection.")

    if st.button("üîÑ Regenerate Meals", type="primary", use_container_width=True):
        # Get the foods that were already shown
        current_foods = st.session_state['meal_plan']['Food'].tolist()
        
        # Rerun the function with exclusion list to get new unique meals
        new_meals = get_recommendations_by_cluster(food_db, st.session_state['predicted_plan'], exclude_names=current_foods)
        st.session_state['meal_plan'] = pd.DataFrame(new_meals)
        st.rerun()

    st.markdown('</div>', unsafe_allow_html=True)